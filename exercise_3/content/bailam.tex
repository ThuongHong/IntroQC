\section{Bài 1}
\textit{Bài làm trong Jupyter Notebook}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{img/cau1.png}
    \caption{Mạch lượng tử tạo trạng thái Bell từ trạng thái cơ sở tính toán}
\end{figure}

\vietnameselst
\lstinputlisting[language=Python, caption="Cài đặt mạch lượng tử tạo trạng thái Bell trên Qiskit"]{code/cau1.py}

Kết quả:
% |00>      | (0.707+0j)|00>   (0.707+0j)|11>
% |01>      | (0.707+0j)|01>   (0.707+0j)|10>
% |10>      | (0.707+0j)|00>   (-0.707+0j)|11>
% |11>      | (0.707+0j)|01>   (-0.707+0j)|10>

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        Input      & Output                                     \\\hline
        $\ket{00}$ & $(0.707+0j)\ket{00} + (0.707+0j)\ket{11}$  \\\hline
        $\ket{01}$ & $(0.707+0j)\ket{01} + (0.707+0j)\ket{10}$  \\\hline
        $\ket{10}$ & $(0.707+0j)\ket{00} + (-0.707+0j)\ket{11}$ \\\hline
        $\ket{11}$ & $(0.707+0j)\ket{01} + (-0.707+0j)\ket{10}$ \\\hline
    \end{tabular}
\end{table}
Mạch lượng tử này chuyển đổi trạng thái cơ sở tính toán sang trạng thái Bell, tức là tạo ra sự vướng víu giữa hai qubit đầu vào.


\section{Bài 2}
\subsection{Câu a}
Một hàm logic là khả nghịch nếu nó là một song ánh.

Quan sát bảng ta thấy không có hàng nào trùng output, do đó hàm này là một song ánh và khả nghịch.

\subsection{Câu b}
Ta tìm hàm Boolean cho $D, E, F$ theo $A, B, C$.

\begin{itemize}
    \item $F$ bằng 1 tại $(0,0,1), (0,1,1), (1,0,1), (1,1,0)$. Ta có biểu thức:
          \begin{align*}
              F & = \overline{A} \overline{B} C + \overline{A} B C + A \overline{B} C + A B \overline{C} \\
                & = \overline{A} C + \overline{B} C + AB\overline{C}                                     \\
                & = AB \oplus C
          \end{align*}
    \item $E$ bằng 1 tại $(0,1,0), (0,1,1), (1,0,0), (1,1,0)$. Ta có biểu thức:
          \begin{align*}
              E & = \overline{A} B  \overline{C} + \overline{A} B C + A \overline{B} \overline{C} + A B \overline{C} \\
                & = \overline{A}B + A\overline{C}
          \end{align*}
    \item $D$ bằng 1 tại $(0,0,0), (0,0,1), (0,1,0), (0,1,1)$. Ta có biểu thức:
          \begin{align*}
              D & = \overline{A} \overline{B} \overline{C} + \overline{A} \overline{B} C + \overline{A} B \overline{C} + \overline{A} B C \\
                & = \overline{A}
          \end{align*}
\end{itemize}

Ta có mạch logic:
\begin{center}
    \begin{circuitikz}[american, scale=0.9, transform shape]
        % Inputs
        \node (A) at (0,0) {$A$};
        \node (B) at (0,-2) {$B$};
        \node (C) at (0,-4) {$C$};

        % NOT gates
        \node[not port, scale=0.6] (notA) at (2,-0.5) {};
        \node[not port, scale=0.6] (notB) at (2,-2.5) {};
        \node[not port, scale=0.6] (notC) at (2,-4.5) {};

        % Connect inputs to NOTs with dots
        \draw (A) -- (1,0) node[circ]{} |- (notA.in);
        \draw (B) -- (1,-2) node[circ]{} |- (notB.in);
        \draw (C) -- (1,-4) node[circ]{} |- (notC.in);

        % NOT outputs with dots
        \draw (notA.out) -- (3.5,-0.5) node[circ]{};
        \draw (notB.out) -- (3.5,-2.5) node[circ]{};
        \draw (notC.out) -- (3.5,-4.5) node[circ]{};

        % D = NOT(A)
        \draw (3.5,-0.5) -- ++(9,0) node[right] {$D$};

        % E = NOT(A)B + A*NOT(C)
        \node[and port, scale=0.6] (andE1) at (6,-6) {};
        \draw (3.5,-0.5) |- (andE1.in 1);
        \draw (1,-2) |- (andE1.in 2);

        \node[and port, scale=0.6] (andE2) at (6,-7.5) {};
        \draw (1,0) |- (andE2.in 1);
        \draw (3.5,-4.5) |- (andE2.in 2);

        \node[or port, scale=0.6] (orE) at (9,-6.75) {};
        \draw (andE1.out) |- (orE.in 1);
        \draw (andE2.out) |- (orE.in 2);
        \draw (orE.out) -- ++(1,0) node[right] {$E$};

        % F = AB XOR C
        \node[and port, scale=0.6] (andAB) at (6,-9) {};
        \draw (1,0) |- (andAB.in 1);
        \draw (1,-2) |- (andAB.in 2);

        \node[xor port, scale=0.6] (xorF) at (9,-9.5) {};
        \draw (andAB.out) |- (xorF.in 1);
        \draw (1,-4) |- (xorF.in 2);
        \draw (xorF.out) -- ++(1,0) node[right] {$F$};
    \end{circuitikz}
\end{center}

\subsection{Câu c}
Dựa trên các hàm Boolean đã rút gọn ở câu b:
\begin{itemize}
    \item $D = \overline{A}$
    \item $E = \overline{A}B + A\overline{C}$
    \item $F = AB \oplus C$
\end{itemize}

Ta thiết kế mạch lượng tử sử dụng 3 qubit đầu vào $\ket{A}, \ket{B}, \ket{C}$ (ký hiệu $q_0, q_1, q_2$) và 3 qubit đầu ra $\ket{D}, \ket{E}, \ket{F}$ (ký hiệu $q_3, q_4, q_5$) được khởi tạo ở trạng thái $\ket{0}$.

Quy trình thực hiện trên mạch (sử dụng các cổng X, CNOT, Toffoli):
\begin{enumerate}
    \item \textbf{Tính F:} Sử dụng cổng Toffoli với điều khiển $q_0, q_1$ lên $q_5$ (tạo $AB$), sau đó dùng CNOT từ $q_2$ lên $q_5$ (tạo $AB \oplus C$).
    \item \textbf{Tính E:}
          \begin{itemize}
              \item Tính $\overline{A}B$: Áp dụng $X(q_0)$, sau đó $Toffoli(q_0, q_1, q_4)$. Sau đó áp dụng $X(q_0)$ để trả lại trạng thái $A$.
              \item Tính $A\overline{C}$: Áp dụng $X(q_2)$, sau đó $Toffoli(q_0, q_2, q_4)$. Sau đó áp dụng $X(q_2)$ để trả lại trạng thái $C$.
          \end{itemize}
    \item \textbf{Tính D:} Áp dụng $X(q_0)$, sau đó $CNOT(q_0, q_3)$. Cuối cùng áp dụng $X(q_0)$ để trả lại trạng thái $A$ ban đầu.
\end{enumerate}

\vietnameselst
\lstinputlisting[language=Python, caption="Cài đặt mạch lượng tử cho hàm f trên Qiskit"]{code/cau2.py}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/cau2.png}
    \caption{Mạch lượng tử thực hiện hàm $f(A,B,C) = (D,E,F)$}
\end{figure}

\subsection{Câu d}
Trạng thái đầu vào là:
$$ \ket{\psi}_{in} = \frac{1}{\sqrt{3}}(\ket{000} + \ket{100} + \ket{111}) $$
Ta xác định đầu ra cho từng thành phần cơ sở dựa trên hàm $f$:
\begin{itemize}
    \item Với $\ket{000}$ ($A=0, B=0, C=0$):
          \begin{itemize}
              \item $D = \overline{0} = 1$
              \item $E = \overline{0}\cdot 0 + 0\cdot \overline{0} = 0$
              \item $F = 0\cdot 0 \oplus 0 = 0$
              \item Kết quả: $\ket{100}$
          \end{itemize}

    \item Với $\ket{100}$ ($A=1, B=0, C=0$):
          \begin{itemize}
              \item $D = \overline{1} = 0$
              \item $E = \overline{1}\cdot 0 + 1\cdot \overline{0} = 1$
              \item $F = 1\cdot 0 \oplus 0 = 0$
              \item Kết quả: $\ket{010}$
          \end{itemize}

    \item Với $\ket{111}$ ($A=1, B=1, C=1$):
          \begin{itemize}
              \item $D = \overline{1} = 0$
              \item $E = \overline{1}\cdot 1 + 1\cdot \overline{1} = 0$
              \item $F = 1\cdot 1 \oplus 1 = 0$
              \item Kết quả: $\ket{000}$
          \end{itemize}
\end{itemize}

Vậy trạng thái đầu ra của hệ 3 qubit chứa giá trị (D, E, F) là:
$$ \ket{\psi}_{out} = \frac{1}{\sqrt{3}}(\ket{100} + \ket{010} + \ket{000}) $$

Kiểm tra lại bằng mạch lượng tử trên Qiskit đã cho kết quả đúng như trên (xem trong notebook).


\section{Bài 3}
Theo \textbf{Định lý không nhân bản (No-Cloning Theorem)}, ta không thể sao chép một trạng thái lượng tử \textit{bất kỳ chưa biết}. Tuy nhiên, $|\Phi^{+}\rangle$ là một trạng thái \textit{đã biết} (trạng thái Bell). Do đó, việc "sao chép" ở đây được hiểu là chuẩn bị (prepare) một trạng thái giống hệt như vậy trên một cặp qubit khác độc lập.

Trạng thái Bell $\ket{\Phi^{+}}$ được định nghĩa là:
$$ \ket{\Phi^{+}} = \frac{1}{\sqrt{2}}(\ket{00} + \ket{11}) $$

Mạch tạo trạng thái này bao gồm một cổng Hadamard ($H$) tác động lên qubit điều khiển và một cổng CNOT tác động lên qubit mục tiêu. Để tạo ra hai bản sao, ta thực hiện quy trình này trên hai cặp qubit riêng biệt (ví dụ: cặp $q_0, q_1$ và cặp $q_2, q_3$).

Trạng thái kỳ vọng của hệ 4 qubit là tích tensor của hai trạng thái Bell:
\begin{align*}
    \ket{\Psi} & = \ket{\Phi^{+}}_{23} \otimes \ket{\Phi^{+}}_{01}                                                                       \\
               & = \left[ \frac{1}{\sqrt{2}}(\ket{00} + \ket{11}) \right] \otimes \left[ \frac{1}{\sqrt{2}}(\ket{00} + \ket{11}) \right] \\
               & = \frac{1}{2} \left( \ket{0000} + \ket{0011} + \ket{1100} + \ket{1111} \right)
\end{align*}

Mạch lượng tử:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{img/cau3.png}
    \caption{Mạch lượng tử tạo hai bản sao của trạng thái Bell $\ket{\Phi^{+}}$}
\end{figure}

Kiểm tra kết quả trên Qiskit cho thấy trạng thái đầu ra đúng như kỳ vọng:
$$ \ket{\Psi} = \frac{1}{2}(\ket{0000} + \ket{0011} + \ket{1100} + \ket{1111}) $$
\begin{itemize}
    \item Cặp bit thấp ($q_1 q_0$) nhận giá trị $00$ hoặc $11$, tương ứng với trạng thái $|\Phi^{+}\rangle$.
    \item Cặp bit cao ($q_3 q_2$) nhận giá trị $00$ hoặc $11$, cũng tương ứng với trạng thái $|\Phi^{+}\rangle$.
    \item Sự xuất hiện của các tổ hợp chéo (ví dụ $|00\rangle_{23}|11\rangle_{01}$) cho thấy hai cặp này độc lập với nhau.
\end{itemize}
Như vậy, ta đã tạo thành công bản sao của trạng thái $|\Phi^{+}\rangle$.

\section{Bài 4}

Giả sử Alice và Bob chia sẻ cặp qubit vướng víu ở trạng thái:
\begin{equation}
    |\Phi^{-}\rangle_{AB} = \frac{1}{\sqrt{2}}(|00\rangle - |11\rangle)
\end{equation}

\subsection{Câu a}
\textbf{Giao thức Mã đậm đặc}

\textbf{Mục tiêu:} Alice gửi 2 bit cổ điển $b_1b_0$ cho Bob bằng cách tác động cổng lượng tử lên qubit $A$ và gửi nó cho Bob.

\textbf{Quy trình:}
\begin{enumerate}
    \item Alice áp dụng cổng $U$ lên qubit $A$ dựa trên 2 bit cần gửi.
    \item Alice gửi qubit $A$ cho Bob.
    \item Bob thực hiện phép đo trong cơ sở Bell trên hệ 2 qubit.
\end{enumerate}

\textbf{Bảng quy ước mã hóa và giải mã:}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Tin nhắn} & \textbf{Cổng Alice ($U_A$)} & \textbf{Trạng thái hệ ($|\psi\rangle_{AB}$)} & \textbf{Kết quả đo của Bob} \\
        $(b_1b_0)$        &                             & $(U_A \otimes I)|\Phi^-\rangle$              & (Trạng thái Bell)           \\
        \hline
        $00$              & $I$                         & $|\Phi^-\rangle$                             & $|\Phi^-\rangle$            \\
        \hline
        $01$              & $X$                         & $-|\Psi^-\rangle$                            & $|\Psi^-\rangle$            \\
        \hline
        $10$              & $Z$                         & $|\Phi^+\rangle$                             & $|\Phi^+\rangle$            \\
        \hline
        $11$              & $ZX$                        & $|\Psi^+\rangle$                             & $|\Psi^+\rangle$            \\
        \hline
    \end{tabular}
    \caption{Giao thức Mã đậm đặc với e-bit $|\Phi^-\rangle$}
\end{table}

\subsection{Câu b}
\textbf{Dịch chuyển lượng tử}

\textbf{Mục tiêu:} Alice muốn chuyển trạng thái $|\psi\rangle_Q = \alpha|0\rangle + \beta|1\rangle$ cho Bob.

\textbf{Quy trình:}
\begin{enumerate}
    \item Alice thực hiện cổng $CNOT$ lên cặp $(Q, A)$ (với $Q$ là điều khiển) và cổng $Hadamard$ lên $Q$.
    \item Alice đo hệ $(Q,A)$ trong cơ sở tính toán, nhận được 2 bit cổ điển $z, x$.
    \item Alice gửi 2 bit này cho Bob.
    \item Bob áp dụng cổng khôi phục lên qubit $B$ để thu được $|\psi\rangle$.
\end{enumerate}

\textbf{Bảng quy ước khôi phục trạng thái:}
Do e-bit là $|\Phi^-\rangle$, trạng thái Bob nhận được sẽ sai khác so với giao thức chuẩn. Bob cần áp dụng các cổng sau để đưa qubit về đúng trạng thái $|\psi\rangle$:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Kết quả đo của Alice} & \textbf{Trạng thái tại Bob} & \textbf{Cổng Bob cần thực hiện} \\
        $(z, x)$                      & (Trước khi khôi phục)       & ($U_{Bob}$)                     \\
        \hline
        $00$                          & $Z|\psi\rangle$             & $\mathbf{Z}$                    \\
        \hline
        $01$                          & $XZ|\psi\rangle$            & $\mathbf{XZ}$                   \\
        \hline
        $10$                          & $|\psi\rangle$              & $\mathbf{I}$                    \\
        \hline
        $11$                          & $-X|\psi\rangle$            & $\mathbf{X}$                    \\
        \hline
    \end{tabular}
    \caption{Bảng khôi phục cho Dịch chuyển lượng tử với e-bit $|\Phi^-\rangle$}
\end{table}


\section{Bài 5}

Cho hàm $f:\mathbb{B}^{2}\rightarrow\mathbb{B}$ với $f(x,y)=x\oplus y$.

\subsection{Câu a}
Oracle lượng tử $U_f$ hoạt động trên 3 qubit theo quy tắc:
$$ U_f|x, y\rangle|z\rangle = |x, y\rangle|z \oplus f(x, y)\rangle = |x, y\rangle|z \oplus x \oplus y\rangle $$
Để thực hiện phép toán này, ta sử dụng hai cổng CNOT:
\begin{itemize}
    \item $CNOT(x, z)$ thực hiện $|z\rangle \to |z \oplus x\rangle$.
    \item $CNOT(y, z)$ thực hiện $|z \oplus x\rangle \to |z \oplus x \oplus y\rangle$.
\end{itemize}
Vậy $U_f$ bao gồm hai cổng CNOT với qubit điều khiển lần lượt là $x, y$ và qubit mục tiêu là $z$.

\subsection{Câu b}
Oracle pha $Z_f$ hoạt động trên 2 qubit theo quy tắc:
$$ Z_f|x, y\rangle = (-1)^{f(x, y)}|x, y\rangle = (-1)^{x \oplus y}|x, y\rangle $$
Ta có tính chất $(-1)^{x \oplus y} = (-1)^x \cdot (-1)^y$. Điều này tương đương với việc áp dụng cổng $Z$ lên qubit $x$ và cổng $Z$ lên qubit $y$.
Vậy $Z_f = Z \otimes Z$.

\subsection{Câu c}
Trạng thái đầu vào:
$$ |+\rangle^{\otimes 2} = |+\rangle|+\rangle = \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle) $$

\textbf{Với Oracle lượng tử $U_f$ (sử dụng thêm qubit ancilla $|-\rangle$ để tạo hiệu ứng phase kickback):}
$$ U_f(|+\rangle|+\rangle|-\rangle) = Z_f|+\rangle|+\rangle $$
Kết quả trên 2 qubit đầu vào sẽ tương tự như tác động của $Z_f$.

\textbf{Với Oracle pha $Z_f$:}
\begin{align*}
    Z_f|+\rangle|+\rangle & = (Z \otimes Z) \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle)                                    \\
                          & = \frac{1}{2}(Z|0\rangle Z|0\rangle + Z|0\rangle Z|1\rangle + Z|1\rangle Z|0\rangle + Z|1\rangle Z|1\rangle)      \\
                          & = \frac{1}{2}(|00\rangle - |01\rangle - |10\rangle + |11\rangle)                                                  \\
                          & = \left(\frac{|0\rangle - |1\rangle}{\sqrt{2}}\right) \otimes \left(\frac{|0\rangle - |1\rangle}{\sqrt{2}}\right) \\
                          & = |-\rangle|-\rangle
\end{align*}

\subsection{Câu d: Kiểm tra trên Qiskit}
\vietnameselst
\lstinputlisting[language=Python, caption="Kiểm tra Oracle pha trên Qiskit"]{code/cau5.py}

Kết quả mô phỏng cho thấy trạng thái đầu ra là $|-\rangle|-\rangle$, khớp với tính toán lý thuyết.

\section{Bài 6}

\textbf{Yêu cầu:} Vẽ mạch và kiểm tra thuật toán Deutsch-Jozsa cho hàm $f_1$ và $f_2$.

\textbf{Phân tích hàm:}
Dựa vào bảng giá trị:
\begin{itemize}
    \item Hàm $f_1(x_1, x_0)$: $f(00)=1, f(01)=1, f(10)=1, f(11)=1$.
          $\Rightarrow f_1$ là \textbf{Hàm Hằng} (Constant), $f_1(x)=1$.
    \item Hàm $f_2(x_1, x_0)$: $f(00)=0, f(01)=0, f(10)=1, f(11)=1$.
          $\Rightarrow f_2(x) = x_1$ (phụ thuộc vào bit cao). Đây là \textbf{Hàm Cân bằng} (Balanced).
\end{itemize}

\textbf{Thiết kế Oracle:}
\begin{itemize}
    \item Oracle $U_{f_1}$: Đảo bit output (hoặc không làm gì nếu dùng phase kickback với $|-\rangle$ thì chỉ cần thêm dấu trừ toàn cục). Để đơn giản, ta có thể dùng cổng $X$ lên qubit ancilla.
    \item Oracle $U_{f_2}$: $f_2(x) = x_1$, nên ta dùng cổng CNOT với điều khiển là qubit $x_1$ và mục tiêu là qubit ancilla.
\end{itemize}

\textbf{Quy trình thuật toán Deutsch-Jozsa:}
\begin{enumerate}
    \item Khởi tạo 2 qubit input ở trạng thái $|0\rangle$ và 1 qubit ancilla ở trạng thái $|1\rangle$.
    \item Áp dụng cổng $H$ lên tất cả các qubit.
    \item Áp dụng Oracle $U_f$.
    \item Áp dụng cổng $H$ lên 2 qubit input.
    \item Đo 2 qubit input.
\end{enumerate}

\textbf{Kết quả dự kiến:}
\begin{itemize}
    \item Với $f_1$ (Hằng): Kết quả đo là $00$.
    \item Với $f_2$ (Cân bằng): Kết quả đo khác $00$ (cụ thể là $10$ vì $f$ phụ thuộc $x_1$).
\end{itemize}

% \vietnameselst
% \lstinputlisting[language=Python, caption="Kiểm tra thuật toán Deutsch-Jozsa trên Qiskit"]{code/cau6.py}

\textbf{Kết quả thực nghiệm:}
\begin{itemize}
    \item Hàm $f_1$: Kết quả đo `00` (xác suất 100\%) $\rightarrow$ Kết luận: Hàm Hằng (Đúng).
    \item Hàm $f_2$: Kết quả đo `10` (xác suất 100\%) $\rightarrow$ Kết luận: Hàm Cân bằng (Đúng).
\end{itemize}
